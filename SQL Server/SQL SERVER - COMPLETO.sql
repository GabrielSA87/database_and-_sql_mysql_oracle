/* DELIMITADOR DO SQL SERVER - GO */

CREATE DATABASE AULA_SQL
GO

USE AULA_SQL
GO

CREATE TABLE TESTE(
	NOME VARCHAR(30)
)
GO

-- MDF E LDF --
/*

MDF = MASTER DATA FILE (ARMAZENA DADOS DO SISTEMA - DICIONARIO)

LDF = LOG DATA FILE (ARMAZENA LOG)

*/


-- ORGANIZAR FISICAMENTE E LOGICAMENTE UM BANCO DE DADOS --
/*

	1 - CRIAR O BANCO COM ARQUIVOS PARA OS SETRORES DE MKT E VENDAS.
	2 - CRIAR UM ARQUIVO GERAL.
	3 - DEIXAR O MDF APENAS COM O DICIONARIO DE DADOS.
	4 - CRIAR 2 GRUPOS DE ARQUIVOS (PRIMARY - MDF).

*/


-- CRIANDO TABELAS --

CREATE TABLE ALUNO(
	IDALUNO INT PRIMARY KEY IDENTITY(1,1), --NO SQL SERVER NO LUGAR DO AUTO_INCREMENT ESCREVE-SE IDENTITY OU IDENTITY(1,1).--
	NOME VARCHAR(30) NOT NULL,
	SEXO CHAR (1) NOT NULL,
	NASCIMENTO DATE NOR NULL,
	EMAIL VARCHAR(30) UNIQUE
)
GO

-- CONSTRAINTS --

ALTER TABLE ALUNO
ADD CONSTRAINT CK_SEXO CHECK (SEXO IN ('M','F'))
GO

-- RELACIONAMENTO 1 X 1 --

CREATE TABLE ENDERECO(
	IDENDERECO INT PRIMARY KEY IDENTITY(100,10),
	BAIRRO VARCHAR(30),
	UF CHAR(2) NOT NULL
	CHECK (UF IN ('RJ','SP','MG')),
	ID_ALUNO INT UNIQUE
)
GO

-- CRIANDO A FK --

ALTER TABLE ENDERECO ADD CONSTRAINT FK_ENDERECO_ALUNO
FOREIGN KEY (ID_ALUNO) REFERENCES ALUNO(IDALUNO)
GO

-- COMANDOS DE DESCRICAO --

-- NO MYSQL TEMOS OS COMANDOS: DESC, SHOW/CREATE TABLE --

-- NO SQL SERVER TEMOS: 'PROCEDURES' (JA CRIADAS E ARMAZENADAS NO SISTEMS) --

SP_COLUMNS ALUNO
GO

SP_HELP ALUNO
GO

-- INSERINDO DADOS --

INSERT INTO ALUNO VALUES ('ANDRE','M','1981/12/09','ANDRE@MAIL.COM') -- NO SQL SERVER NAO PRECISA PASSAR O VALOR 'NULL' PARA O CAMPO ID --
INSERT INTO ALUNO VALUES ('ANA','F','1978/03/14','ANA@MAIL.COM')
INSERT INTO ALUNO VALUES ('RUI','M','1965/07/25','RUI@MAIL.COM')
INSERT INTO ALUNO VALUES ('JOAO','M','2002/11/29','JOAO@MAIL.COM')
GO

SELECT * FROM ALUNO
GO

INSERT INTO ENDERECO VALUES ('FLAMENGO','RJ',1)
INSERT INTO ENDERECO VALUES ('MORUMBI','SP',2)
INSERT INTO ENDERECO VALUES ('CENTRO','MG',4)
INSERT INTO ENDERECO VALUES ('CENTRO','SP',6)
GO

-- CRIANDO TABELA TELEFONE --

CREATE TABLE TELEFONE(
	IDTELEFONE INT PRIMARY KEY IDENTITY,
	TIPO CHAR(3) NOT NULL,
	NUMERO VARCHAR(10) NOT NULL,
	ID_ALUNO INT,
	CHECK (TIPO IN ('RESIDENCIAL','COMERCIAL','CELULAR'))
)
GO

INSERT INTO TELEFONE VALUES ('CELULAR','789456123',1)
INSERT INTO TELEFONE VALUES ('RESIDENCIAL','345678941',1)
INSERT INTO TELEFONE VALUES ('COMERCIAL','3421567890',2)
INSERT INTO TELEFONE VALUES ('CELULAR','987542136',2)
GO

SELECT * FROM ALUNO
GO


-- CLAUSULA AMBIGUA (COLUNAS IGUAIS EM UM JOIN) --

SELECT A.NOME, T.TIPO, T.NUMERO, E.BAIRRO, E.UF
FROM ALUNO A
	LEFT JOIN TELEFONE T
	ON A.IDALUNO = T.ID_ALUNO
	INNER JOIN ENDERECO E
	ON A.IDALUNO = E.ID_ALUNO
GO

-- IFNULL --

SELECT A.NOME,
	   ISNULL (T.TIPO, 'SEM') AS 'TIPO',
	   ISNULL (T.NUMERO, 'NUMERO') AS 'TELEFONE',
	   E.BAIRRO,
	   E.UF
	FROM ALUNO A
		LEFT JOIN TELEFONE T
		ON A.IDALUNO = T.ID_ALUNO
		INNER JOIN ENDERECO E
		ON A.IDALUNO = E.ID_ALUNO
GO


-- **** DATAS **** --

SELECT NOME, NASCIMENTO
FROM ALUNO
GO

-- RETORNAR DATA ATUAL --

SELECT GETDATE() --FORMATO: yyyy-MM-dd hh:mm:ss--
GO

-- DATEIFF - CALCULA A DIFERENCA ENTRE DUAS DATAS --

SELECT NOME, (DATEIFF(DAY,NASCIMENTO,GETDATE())/365.2425) AS 'IDADE' --DIVIDIDO POR 365.2425 PARA CONSIDERAR O ANO BISEXTO--
FROM ALUNO
GO

SELECT NOME, (DATEIFF(MONTH,NASCIMENTO,GETDATE())/12) AS 'IDADE' --DIVIDIDO POR 365.2425 PARA CONSIDERAR O ANO BISEXTO--
FROM ALUNO
GO

SELECT NOME, DATEIFF(YEAR,NASCIMENTO,GETDATE()) AS 'IDADE' --DIVIDIDO POR 365.2425 PARA CONSIDERAR O ANO BISEXTO--
FROM ALUNO
GO

 -- TRAZER O NOME DA PARTE DA DATA EM QUESTAO --
 
SELECT NOME, DATANAME(MONTH, NASCIMENTO)
FROM ALUNO
GO
 
SELECT NOME, DATANAME(YEAR, NASCIMENTO)
FROM ALUNO
GO 

SELECT NOME, DATANAME(WEEKDAY, NASCIMENTO)
FROM ALUNO
GO

-- DATEPART - IGUAL AO DATANAME, MAS COMO INTEIRO --

SELECT NOME, DATEPART(MONTH, NASCIMENTO)
FROM ALUNO
GO

SELECT NOME, DATEPART(MONTH, NASCIMENTO), DATENAME(MONTH, NASCIMENTO)
FROM ALUNO
GO

-- DATEADD - RETORNA UMA DATA SOMANDO A OUTRA DATA --

SELECT DATEADD(DAY,365,GETDATE())
GO

SELECT DATEADD(YEAR,10,GETDATE())
GO

-- **** CONVERSAO DE DADOS **** --

SELECT 1 + '1' --RETORNARA 2--
GO

SELECT '1' + '1' --RETORNARA 11--
GO

SELECT 'CURSO' + '1' --RETORNARA CURSO1--
GO

SELECT 'CURSO' + 1 --RETORNARA UM ERRO, POIS O SQL SERVER TENTOU CONCATENAR UMA STRING COM UM INT, ISSO FORCARA UMA STRING PARA UM INT, RESULTANDO NESSE CASO EM ERRO--
GO

-- FUNCOES DE CONVERSAO DE DADOS --

SELECT CAST('1' AS INT) + CAST('1'AS INT) --RETORNARA 2--
GO

-- CONVERSAO E CONCATENACAO
-- https://msdn.microsoft.com/en-us/library/ms191530.aspx --

SELECT NOME, CAST(DAY(NASCIMENTO) AS VARCHAR) + '/' + CAST(MONTH(NASCIMENTO) AS VARCHAR) + '/' + CAST(YEAR(NASCIMENTO) AS VARCHAR) AS 'NASCIMENTO'
FROM ALUNO
GO

-- **** CHARINDEX **** -- CHARINDEX(O QUE, ONDE, A PARTIR DE) RESULTADO --
-- RETONA UM INTEIRO BASEADO NUMA BUSCA EM UMA COLUNA --

SELECT NOME, CHARINDEX('A',NOME) AS INDICE --COMO "A PARTIR DE" NAO FOI PASSADO AQUI, ELE VAI CONSIDERAR SENDO 01 (DEFAULT)-
FROM ALUNO
GO

 ------- -------
|NOME	|INDICE |
 ------- -------
|ANDRE  |1	|
|ANA	|1	|
|RUI	|0	|
|JOAO	|3	|
 ------- -------

SELECT NOME, CHARINDEX('A',NOME,2) AS INDICE
FROM ALUNO
GO

 ------- -------
|NOME	|INDICE |
 ------- -------
|ANDRE  |0	|
|ANA	|3	|
|RUI	|0	|
|JOAO	|3	|
 ------- -------


-- **** BULK INSERT - IMPORTACAO DE ARQUIVOS **** --

CREATE TABLE LANCAMENTO_CONTABIL(
	CONTA INT,
	VALOR INT,
	DEB_CRED CHAR(1)
);
GO

SELECT * FROM LANCAMENTO_CONTABIL
GO

BULK INSERT LANCAMENTO_CONTABIL
FROM 'C:\LOCALDOARQUIVO\CONTAS.TXT'
WITH
(
	FIRSTROW = 2,
	DETAFILETYPE = 'CHAR',
	FIELDTERMINATOR = '\t', -- \t = TAB --
	ROWTERMINATOR = '\n' -- \n = ENTER --
)
GO

SELECT * FROM LANCAMENTO_CONTABIL
GO

/*

CONTA	VALOR		TIPO
1		9584		D
1		46545		D
1		4654		D
1		45646556	D
1		46545		D
1		9554		D
1		478945		D
1		9568		D
1		5784		D
1		48		D
1		478946		D
1		7156		D
2		4111		D
2		6456145		D
2		46545		D
2		47986465	D
2		478945		D
2		9568		D
2		5784		D
2		48		D
2		478946		D
2		7156		D
2		4111		C
1		4111		C
1		4111		C
1		4111		C
1		478651		C
1		4111		C
1		4111		C
1		4111		C
1		4111		C
1		787464		C
1		4111		C
1		4111		C
1		4111		C
1		8796541		C
1		4111		C
1		4111		C
1		4111		C
1		4111		C
4		4111		C
4		4111		C
4		4111		C
4		4111		C
4		4111		C
4		45646556	C
4		46545		C
4		47986465	C
4		45646556	D
1		46545		D
1		955444		D
1		478945		D
1		9568		D
1		5784		D
1		48		D
1		478946		D
1		7156		D
1		4111		D
1		9584		D
1		46545		D
1		4654		D
1		45646556	D
1		46545		D
1		9554		D
1		478945		D
1		9568		D
1		5784		D
1		48		C
1		478946		C
1		7156		C
1		4111		C
1		6456145		C
1		46545		C
1		47986465	C
1		478945		C
1		9568		C
1		5784		C
1		48		C
1		478946		C
1		7156		C
1		4111		C
1		4111		C
1		4111		D
1		4111		D
1		478651		D
1		4111		D
1		4111		D
1		4111		D
1		4111		D
1		787464		D
1		4111		D
1		4111		D
1		4111		D
1		8796541		D
1		4111		D
1		4111		D
1		4111		D
1		4111		D
1		4111		D
1		4111		D
1		4111		D
1		4111		D
1		4111		D
1		45646556	D
1		46545		D
5		47986465	D
5		45646556	D
5		46545		D
5		955444		D
5		478945		D
5		9568		D
5		5784		D
5		48		D
5		478946		D
5		7156		D
5		4111		D
5		46545		D
2		955444		D
2		478945		D
2		9568		D
2		5784		D
2		48		D
2		478946		D
2		7156		C
2		4111		C
2		46545		C
2		47986465	C
2		478945		C
2		9568		C
2		5784		C
...

*/


 -- DESAFIO DO SALDO --
 /*
		1 - QUERY QUE TRAGA O NUMERO DA CONTA;
		2 - QUERY QUE TRAGA O SALDO DELA - DEVEDOR OU CREDOR.
 */

SELECT CONTA, VALOR, DEB_CRED,
CHARINDEX ('D',DEB_CRED) AS 'DEBITO',
CHARINDEX ('C',DEB_CRED) AS 'CREDITO',
CHARINDEX ('C', DEB_CRED) * 2 - 1 AS MULTIPLICADOR,
FROM LANCAMENTO_CONTABIL
GO

SELECT CONTA
SUM(VALOR * ((CHARINDEX('C', DEB_CRED) * 2) - 1) AS SALDO
FROM LANCAMENTO_CONTABIL
GROUP BY CONTA
GO

/*---------------------------------------------------------------------------------------------------------------------*/
-- **** TRIGGERS DE DML **** --

USE EMPRESA
GO

CREATE TABLE PRODUTOS(
	IDPRODUTO INT IDENTITY PRIMARY KEY,
	NOME VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECO NUMERIC(10,2) NOT NULL 	-- NUMERIC CORRESPONDE AO FLOAT DO MYSQL --
)
GO

CREATE TABLE HISTORICO(
	IDOPERACAO INT IDENTITY PRIMARY KEY,
	PRODUTO VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECOANTIGO NUMERIC(10,2) NOT NULL,
	PRECONOVO NUMERIC(10,2) NOT NULL,
	DATA DATETIME,
	USUARIO VARCHAR(30),
	MENSAGEM VARCHAR (100)
)
GO

INSERT INTO PRODUTOS VALUES ('LIVRO SQL SERVER','LIVROS',98.00)
INSERT INTO PRODUTOS VALUES ('LIVRO ORACLE','LIVROS',50.00)
INSERT INTO PRODUTOS VALUES ('LICENCA POWERCENTER','SOFTWARES',45000.00)
INSERT INTO PRODUTOS VALUES ('NOTEBOOK I7','COMPUTADORES',3150.00)
INSERT INTO PRODUTOS VALUES ('LIVRO BUSINESS INTELLIGENCE','LIVROS',90.00)

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO
GO

-- CTRL+R -> PARA LIMPAR O HISTORICO --

-- VERIFICAR O USUARIO --

SELECT SUSER_NAME()
GO

-- TRIGGER DE DADOS - DML - DATA MANIPULATION LANGUAGE --

CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE
AS
	DECLARE @IDPRODUTO INT
	DECLARE @PRODUTO VARCHAR(30)
	DECLARE @CATEGORIA VARCHAR(10)
	DECLARE @PRECO NUMERIC(10,2)
	DECLARE @PRECONOVO NUMERIC(10,2)
	DECLARE @DATA DATETIME
	DECLARE @USUARIO VARCHAR(30)
	DECLARE @ACAO VARCHAR(100)
	
	--PRIMEIRO BLOCO - POR BOA PRATICA, VALORES VINDO DE TABELAS SAO INSERIDOS COM O COMANDO 'SELECT'--
	SELECT @IDPRODUTO = IDPRODUTO FROM INSERTED
	SELECT @PRODUTO = NOME FROM INSERTED
	SELECT @CATEGORIA = CATEGORIA FROM INSERTED
	SELECT @PRECO = PRECO FROM DELETED
	SELECT @PRECONOVO = PRECO FROM INSERTED
	
	--SEGUNDO BLOCO - POR BOA PRATICA, VALORES VINDO DE FUNCOES OU VALORES LITERAIS DEVEM SER ATRIBUIDOS COM O COMANDO 'SET'--
	SET @DATA = GETDATE()
	SET @USUARIO = SUSER_NAME()
	SET @ACAO = 'VALOR INSERIDO PELA TRIGGER: TRG_ATUALIZA_PRECO'

	INSERT INTO HISTORICO(PRODUTO,CATEGORIA,PRECOANTIGO,PRECONOVO,DATA,USUARIO,MENSAGEM)
	VALUES (@PRODUTO,@CATEGORIA,@PRECO,@PRECONOVO,@DATA,@USUARIO,@ACAO)
	
	PRINT 'TRIGGER EXECUTADA COM SUCESSO!'
GO


-- EXECUTANDO UM UPDATE --

UPDATE PRODUTOS SET PRECO = 100.00
WHERE IDPRODUTO = 1
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO
GO

UPDATE PRODUTOS SET NOME = 'LIVRO C#'
WHERE IDPRODUTO = 1
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO
GO


-- PROGRAMANDO TRIGGER EM UMA COLUNA --

DROP TRIGGER TRG_ATUALIZA_PRECO
GO

CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO)
BEGIN	
	
	DECLARE @IDPRODUTO INT
	DECLARE @PRODUTO VARCHAR(30)
	DECLARE @CATEGORIA VARCHAR(10)
	DECLARE @PRECO NUMERIC(10,2)
	DECLARE @PRECONOVO NUMERIC(10,2)
	DECLARE @DATA DATETIME
	DECLARE @USUARIO VARCHAR(30)
	DECLARE @ACAO VARCHAR(100)
	
	--PRIMEIRO BLOCO - POR BOA PRATICA, VALORES VINDO DE TABELAS SAO INSERIDOS COM O COMANDO 'SELECT'--
	SELECT @IDPRODUTO = IDPRODUTO FROM INSERTED
	SELECT @PRODUTO = NOME FROM INSERTED
	SELECT @CATEGORIA = CATEGORIA FROM INSERTED
	SELECT @PRECO = PRECO FROM DELETED
	SELECT @PRECONOVO = PRECO FROM INSERTED
	
	--SEGUNDO BLOCO - POR BOA PRATICA, VALORES VINDO DE FUNCOES OU VALORES LITERAIS DEVEM SER ATRIBUIDOS COM O COMANDO 'SET'--
	SET @DATA = GETDATE()
	SET @USUARIO = SUSER_NAME()
	SET @ACAO = 'VALOR INSERIDO PELA TRIGGER: TRG_ATUALIZA_PRECO'

	INSERT INTO HISTORICO(PRODUTO,CATEGORIA,PRECOANTIGO,PRECONOVO,DATA,USUARIO,MENSAGEM)
	VALUES (@PRODUTO,@CATEGORIA,@PRECO,@PRECONOVO,@DATA,@USUARIO,@ACAO)
	
	PRINT 'TRIGGER EXECUTADA COM SUCESSO!'

END
GO

UPDATE PRODUTOS SET PRECO = 300.00
WHERE IDPRODUTO = 2
GO

SELECT * FROM HISTORICO
GO

UPDATE PRODUTOS SET NOME = 'LIVRO JAVA'
WHERE IDPRODUTO = 2
GO

SELECT * FROM HISTORICO
GO


-- **** VARIAVEIS COM SELECT **** --

CREATE TABLE RESULTADO(
	IDRESULTADO INT PRIMARY KEY IDENTITY,
	RESULTADO INT
)
GO

INSERT INTO RESULTADO VALUES((SELECT 10 + 10))
GO


-- ATRIBUINDO SELECTS A VARIAVEIS - ANONIMO --

DECLARE
	@RESULT INT
	SET @RESULTADO = (SELECT 50 + 50)
	INSERT INTO RESULTADO VALUES(@RESULTADO)
	PRINT 'VALOR INSERIDO NA TABELA.' + CAST(@RESULTADO AS VARCHAR)
GO


-- TRIGGER UPDATE --

CREATE TABLE EMPREGADO(
	IDEMRPEGADO INT PRIMARY KEY IDENTITY,
	NOME VARCHAR(30),
	SALARIO MONEY --MONEY JA VEM COMO PADRAO O SEPARADOR E DUAS CASAS DECIMAIS--
	IDGERENTE INT
)
GO

ALTER TABLE EMPREGADO ADD CONSTRAINT FK_GERENTE
FOREIGN KEY(IDGERENTE) REFERENCES EMPREGADO(IDEMPREGADO)
GO

INSERT INTO EMPREGADO VALUES (1,'CLARA',5000.00,NULL)
INSERT INTO EMPREGADO VALUES (2,'CELIA',4000.00,1)
INSERT INTO EMPREGADO VALUES (3,'JOAO',4000.00,1)
GO

CREATE TABLE HIST_SALARIO(
	IDEMPREGADO INT,
	SALARIO_ANTIGO MONEY,
	SALARIO_NOVO MONEY,
	DATA DATETIME
)
GO

CREATE TRIGGER TG_SALARIO
ON DBO.EMPREGADO
FOR UPDATE AS
IF UPDATE(SALARIO)
BEGIN
	ISNERT INTO HIST_SALARIO
	(IDEMPREGADO,SALARIO_ANTIGO,SALARIO_NOVO,DATA)
	SELECT D.IDEMPREGADO, D.SALARIO, I.SALARIO, GETDATE()
	FROM DELETED D, INSERTED I
	WHERE D.IDEMPREGADO = I.IDEMPREGADO
END
GO

UPDATE EMPREGADO SET SALARIO = SALARIO * 1.1
GO

SELECT * FROM EMPREGADO
GO


SELECT * FROM HIST_SALARIO
GO


-- EXERCICIO - RETORNAR SALARIO ANTIGO, NOVO, DATA E NOME DO EMPREGADO --

CREATE TABLE SALARIO_RANGE(
	MINSAL MONEY,
	MAXSAL MONEY
)
GO

INSERT INTO SALARIO_RANGE VALUES(3000.00,6000.00)
GO

CREATE TRIGGER TG_RANGE
ON DBO.EMPREGADO
FOR INSERT,UPDATE
AS
	DECLARE
		@MINSAL MONEY,
		@MAXSAL MONEY,
		@ATUALSAL MONEY
	
	SELECT @MINSAL = MINSAL, @MAXSAL = MAXSAL FROM SALARIO_RANGE
	SELECT @ATUALSAL = I.SALARIO FROM INSERTED I
	
	IF(@ATUALSAL < @MINSAL)
	BEGIN
		RAISEERROR('SALARIO MENOR QUE O PISO.',16,1)
		ROLLBACK TRANSACTION
	END
	
	IF(@ATUALSAL > @MAXSAL)
	BEGIN
		RAISEERROR('SALARIO MAIOR QUE O TETO.',16,1)
		ROLLBACK TRANSACTION
	END
GO

UPDATE EMPREGADO SET SALARIO = 9000.00
WHERE IDEMPREGADO = 1
GO

UPDATE EMPREGADO SET SALARIO = 1000.00
WHERE IDEMPREGADO = 1
GO

-- VERIFICANDO O TEXTO DE UMA TRIGGER --

SP_HELPTEXT TG_RANGE
GO

/*---------------------------------------------------------------------------------------------------------------------*/

-- PROCEDURES - SP_STORAGE PROCEDURE--

CREATE TABLE PESSOA(
	IDPESSOA INT PRIMARY KEY IDENTITY,
	NOME VARCHAR(30) NOT NULL,
	SEXO CHAR(1) NOT NULL CHECK (SEXO IN('F','M')),
	NASCIMENTO DATE NOT NULL
)
GO

CREATE TABLE TELEFONE(
	IDTELEFONE INT NOT NULL IDENTITY,
	TIPO CHAR(3) NOT NULL CHECK (TIPO IN('COM','CEL')),
	NUMERO CHAR(10) NOT NULL,
	ID_PESSOA INT
)
GO

ALTER TABLE TELEFONE ADD CONSTRAINT FK_TELEFONE_PESSOA
FOREIGN KEY (ID_PESSOA) REFERENCES PESSOA(IDPESSOA)
ON DELETE CASCADE
GO

INSERT INTO PESSOA VALUES('ANTONIO','M','1981-02-13')
INSERT INTO PESSOA VALUES('DANIEL','M','1985-03-18')
INSERT INTO PESSOA VALUES('CLEIDE','F','1979-10-13')
INSERT INTO TELEFONE VALUES('CEL','987900880',1)
INSERT INTO TELEFONE VALUES('COM','879458625',1)
INSERT INTO TELEFONE VALUES('CEL','997586210',2)
INSERT INTO TELEFONE VALUES('CEL','987100235',2)
INSERT INTO TELEFONE VALUES('COM','34550125',3)
INSERT INTO TELEFONE VALUES('COM','32559080',2)
INSERT INTO TELEFONE VALUES('CEL','990011223',3)
GO

-- CRIANDO A PROCEDURE --

CREATE PROC SOMA
AS
	SELECT 10 + 10 AS SOMA
GO

-- EXECUCAO DA PROCEDURE --

EXEC SOMA
GO

-- DINAMICAS - COM PARAMETROS --

CREATE PROC CONTA @NUM1 INT, @NUM2 INT
AS
	SELECT @NUM1 + @NUM2 AS RESULTADO
GO

-- EXECUTANDO --

EXEC CONTA 90, 78
GO

--APAGANDO A PROCEDURE --

DROP PROC CONTA
GO


-- PROCEDURES EM TABLEAS --

SELECT NOME, NUMERO
FROM PESSOA
INNER JOIN TELEFONE
ON IDPESSOA = ID_PESSOA
WHERE TIPO = 'CEL'
GO


-- TRAZER OS TELEFONES DE ACORDO COM O TIPO PASSADO POR PARAMETRO --

CREATE PROC TELEFONES @TIPO CHAR(3)
AS
	SELECT NOME, NUMERO
	FROM PESSOA
	INNER JOIN TELEFONE
	ON IDPESSOA = ID_PESSOA
	WHERE TIPO = @TIPO
GO

EXEC TELEFONES 'CEL'
GO

EXEC TELEFONES 'COM'
GO


-- PARAMETROS DE OUTPUT --

SELECT TIPO, COUNT(*) AS QUANTIDADE
FROM TELEFONE
GROUP BY TIPO
GO

-- CRIANDO PROCEDURE COM PARAMETRO DE ENTRADA E PARAMETRO DE SAIDA --

CREATE PROC GETTIPO @TIPO CHAR(3), @CONTADOR INT OUTPUT
AS
	SELECT @CONTADOR = COUNT(*)
	FROM TELEFONE
	WHERE TIPO = @TIPO
GO

-- EXECUCAO DA PROC COM PARAM DE SAIDA --
/*
	TRANSACTION SQL - LINGUAGEM QUE O SQL SERVER TRABALHA.
*/

DECLARE @SAIDA INT
EXEC GETTIPO @TIPO = 'CEL', @CONTADOR = @SAIDA OUTPUT
SELECT @SAIDA
GO


/*----------------------------------------------------------------------------------------------------------------------*/

-- PROCEDURE DE CADASTRO --

CREATE PROC CADASTRO @NOME VARCHAR(30), @SEXO CHAR(1), @NASCIMENTO DATE, @TIPO CHAR(3), @NUMERO VARCHAR(10)
AS
	DECLARE @Fk INT
	
	INSERT INTO PESSOA VALUES (@NOME, @SEXO, @NASCIMENTO) -- GERAR UM ID --
	
	SET @FK = (SELECT IDPESSOA FROM PESSOA WHERE IDPESSOA = @@IDENTITY)
	
	INSERT INTO TELEFONE VALUES (@TIPO,@NUMERO,@FK)
GO


CADASTRO 'JORGE','M','1981-01-01','CEL','997586239'
GO

SELECT PESSOA.*,TELEFONE.* -- .* IRA RETORNAR TUDO --
FROM PESSOA
INNER JOIN TELEFONE
ON IDPESSOA = ID_PESSOA
GO
